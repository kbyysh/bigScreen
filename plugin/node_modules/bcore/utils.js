Cube("/node_modules/bcore/utils.js", [], function (module, exports, require, load, process, global) {

  function _instanceof(left, right) {if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {return !!right[Symbol.hasInstance](left);} else {return left instanceof right;}}
  function _typeof(obj) {"@babel/helpers - typeof";return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {return typeof obj;} : function (obj) {return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;}, _typeof(obj);}
  function traver(parent, cb) {
    var child;
    for (var key in parent) {
      child = parent[key];
      if (child && _typeof(child) === 'object') {
        cb(key, child, parent);
        traver(child, cb);
      }
    }
  }
  function isNone(d) {
    return d === null || d === undefined || isNaN(d);
  }
  var root = void 0;
  function merge(dest) {
    var sources = Array.prototype.slice.call(arguments, 1),
    i,
    j,
    len,
    src;
    for (j = 0, len = sources.length; j < len; j++) {
      src = sources[j] || {};
      for (i in src) {
        if (src.hasOwnProperty(i)) {
          dest[i] = src[i];
        }
      }
    }
    return dest;
  }
  function clone(obj) {
    var result = Array.isArray(obj) ? [] : {};
    for (var k in obj) {
      if (obj.hasOwnProperty(k)) {
        result[k] = obj[k];
      }
    }
    return result;
  }
  function deepClone(src) {
    var input = Array.isArray(src) ? [] : {};
    return deepMerge(input, src);
  }
  function isNeedClone(d) {
    if (!d) return false;
    if (root.HTMLElement && _instanceof(d, root.HTMLElement)) return false;
    if (root.HTMLElement && d[0] && _instanceof(d[0], HTMLElement)) return false;
    if (d.globalCompositeOperation) return false;
    return true;
  }
  function _isObject(v) {
    return v && _typeof(v) === 'object' && !_instanceof(v, Date);
  }
  var maxDepth = 8;
  function deepMerge(dest, src, directs, depth) {
    var i,
    j,
    len,
    src,
    depth = depth || 0;
    var result = clone(dest);
    if (depth >= maxDepth) {
      console.log('层数过深, 全部继承');
      return src;
    }
    depth++;
    for (i in src) {
      if (src.hasOwnProperty(i)) {
        var value = src[i];
        var destValue = dest[i];
        if (value === destValue) continue;
        if (value === undefined) continue;
        if (_isObject(destValue) && _isObject(value)) {
          if (!isNeedClone(value) || directs && i in directs) {
            result[i] = value;
            continue;
          }
          if (Array.isArray(destValue) !== Array.isArray(value)) {
            value = deepClone(value);
            result[i] = value;
            continue;
          }
          result[i] = deepMerge(destValue, value, directs, depth);
          continue;
        }
        if (_isObject(value) && isNeedClone(value)) value = deepClone(value);
        result[i] = value;
      }
    }
    return result;
  }
  function deepMergeWithoutArray(dest, src, directs, depth) {
    var i,
    j,
    len,
    src,
    depth = depth || 0;
    var result = clone(dest);
    if (depth >= maxDepth) {
      console.log('层数过深, 全部继承');
      return src;
    }
    depth++;
    for (i in src) {
      if (src.hasOwnProperty(i)) {
        var value = src[i];
        var destValue = dest[i];
        if (value === destValue) continue;
        if (value === undefined) continue;
        if (destValue && _typeof(destValue) === 'object' && _typeof(value) === 'object') {
          if (Array.isArray(destValue) && Array.isArray(value)) {
            result[i] = value;
            continue;
          }
          if (!isNeedClone(value) || directs && i in directs) {
            result[i] = value;
            continue;
          }
          if (Array.isArray(destValue) !== Array.isArray(value)) {
            value = deepClone(value);
            result[i] = value;
            continue;
          }
          result[i] = deepMergeWithoutArray(destValue, value, directs, depth);
          continue;
        }
        if (_typeof(value) === 'object' && isNeedClone(value)) value = deepClone(value);
        result[i] = value;
      }
    }
    return result;
  }
  function switchValue(f, a, b, c, d) {
    if (typeof f === 'function') return f(a, b, c, d);
    return f;
  }
  var root;
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object') {
    root = window;
  } else {
    root = {};
  }
  function getContainer(container) {
    if (root.HTMLElement && _instanceof(container, root.HTMLElement)) return container;
    if (root.HTMLElement && container[0] && _instanceof(container[0], root.HTMLElement)) return container[0];
    if (typeof container === 'string') {
      if (container.charAt(0) === '.') {
        var className = container.slice(1);
        return container = document.getElementsByClassName(className)[0];
      } else {
        var id;
        if (container.charAt(0) !== '#') {
          id = container;
        } else {
          id = container.slice(1);
        }
        return container = document.getElementById(id);
      }
      if (!container) {
        throw '没有container ';
      }
    }
    return container;
  }
  module.exports = {
    'getContainer': getContainer,
    'merge': merge,
    'extend': merge,
    'isNone': isNone,
    'traver': traver,
    'deepMerge': deepMerge,
    'clone': clone,
    'deepClone': deepClone,
    'switchValue': switchValue,
    'deepMergeWithoutArray': deepMergeWithoutArray };return module.exports;});