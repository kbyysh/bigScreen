Cube("/node_modules/axios/lib/adapters/http.js", ["/node_modules/axios/lib/utils.js", "/node_modules/axios/lib/core/settle.js", "/node_modules/axios/lib/core/buildFullPath.js", "/node_modules/axios/lib/helpers/buildURL.js", "/node_modules/follow-redirects/index.js", "/node_modules/axios/lib/env/data.js", "/node_modules/axios/lib/core/createError.js", "/node_modules/axios/lib/core/enhanceError.js", "/node_modules/axios/lib/defaults.js", "/node_modules/axios/lib/cancel/Cancel.js"], function (module, exports, require, load, process, global) {

  var utils = require('/node_modules/axios/lib/utils.js');
  var settle = require('/node_modules/axios/lib/core/settle.js');
  var buildFullPath = require('/node_modules/axios/lib/core/buildFullPath.js');
  var buildURL = require('/node_modules/axios/lib/helpers/buildURL.js');
  var http = require('http');
  var https = require('https');
  var httpFollow = require('/node_modules/follow-redirects/index.js').http;
  var httpsFollow = require('/node_modules/follow-redirects/index.js').https;
  var url = require('url');
  var zlib = require('zlib');
  var VERSION = require('/node_modules/axios/lib/env/data.js').version;
  var createError = require('/node_modules/axios/lib/core/createError.js');
  var enhanceError = require('/node_modules/axios/lib/core/enhanceError.js');
  var defaults = require('/node_modules/axios/lib/defaults.js');
  var Cancel = require('/node_modules/axios/lib/cancel/Cancel.js');
  var isHttps = /https:?/;
  function setProxy(options, proxy, location) {
    options.hostname = proxy.host;
    options.host = proxy.host;
    options.port = proxy.port;
    options.path = location;
    if (proxy.auth) {
      var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');
      options.headers['Proxy-Authorization'] = 'Basic ' + base64;
    }
    options.beforeRedirect = function beforeRedirect(redirection) {
      redirection.headers.host = redirection.host;
      setProxy(redirection, proxy, redirection.href);
    };
  }
  module.exports = function httpAdapter(config) {
    return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
      var onCanceled;
      function done() {
        if (config.cancelToken) {
          config.cancelToken.unsubscribe(onCanceled);
        }
        if (config.signal) {
          config.signal.removeEventListener('abort', onCanceled);
        }
      }
      var resolve = function resolve(value) {
        done();
        resolvePromise(value);
      };
      var reject = function reject(value) {
        done();
        rejectPromise(value);
      };
      var data = config.data;
      var headers = config.headers;
      var headerNames = {};
      Object.keys(headers).forEach(function storeLowerName(name) {
        headerNames[name.toLowerCase()] = name;
      });
      if ('user-agent' in headerNames) {
        if (!headers[headerNames['user-agent']]) {
          delete headers[headerNames['user-agent']];
        }
      } else {
        headers['User-Agent'] = 'axios/' + VERSION;
      }
      if (data && !utils.isStream(data)) {
        if (Buffer.isBuffer(data)) {} else if (utils.isArrayBuffer(data)) {
          data = Buffer.from(new Uint8Array(data));
        } else if (utils.isString(data)) {
          data = Buffer.from(data, 'utf-8');
        } else {
          return reject(createError('Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream', config));
        }
        if (!headerNames['content-length']) {
          headers['Content-Length'] = data.length;
        }
      }
      var auth = undefined;
      if (config.auth) {
        var username = config.auth.username || '';
        var password = config.auth.password || '';
        auth = username + ':' + password;
      }
      var fullPath = buildFullPath(config.baseURL, config.url);
      var parsed = url.parse(fullPath);
      var protocol = parsed.protocol || 'http:';
      if (!auth && parsed.auth) {
        var urlAuth = parsed.auth.split(':');
        var urlUsername = urlAuth[0] || '';
        var urlPassword = urlAuth[1] || '';
        auth = urlUsername + ':' + urlPassword;
      }
      if (auth && headerNames.authorization) {
        delete headers[headerNames.authorization];
      }
      var isHttpsRequest = isHttps.test(protocol);
      var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
      var options = {
        path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ''),
        method: config.method.toUpperCase(),
        headers: headers,
        agent: agent,
        agents: {
          http: config.httpAgent,
          https: config.httpsAgent },

        auth: auth };

      if (config.socketPath) {
        options.socketPath = config.socketPath;
      } else {
        options.hostname = parsed.hostname;
        options.port = parsed.port;
      }
      var proxy = config.proxy;
      if (!proxy && proxy !== false) {
        var proxyEnv = protocol.slice(0, -1) + '_proxy';
        var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
        if (proxyUrl) {
          var parsedProxyUrl = url.parse(proxyUrl);
          var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
          var shouldProxy = true;
          if (noProxyEnv) {
            var noProxy = noProxyEnv.split(',').map(function trim(s) {
              return s.trim();
            });
            shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
              if (!proxyElement) {
                return false;
              }
              if (proxyElement === '*') {
                return true;
              }
              if (proxyElement[0] === '.' && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                return true;
              }
              return parsed.hostname === proxyElement;
            });
          }
          if (shouldProxy) {
            proxy = {
              host: parsedProxyUrl.hostname,
              port: parsedProxyUrl.port,
              protocol: parsedProxyUrl.protocol };

            if (parsedProxyUrl.auth) {
              var proxyUrlAuth = parsedProxyUrl.auth.split(':');
              proxy.auth = {
                username: proxyUrlAuth[0],
                password: proxyUrlAuth[1] };

            }
          }
        }
      }
      if (proxy) {
        options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');
        setProxy(options, proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
      }
      var transport;
      var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
      if (config.transport) {
        transport = config.transport;
      } else if (config.maxRedirects === 0) {
        transport = isHttpsProxy ? https : http;
      } else {
        if (config.maxRedirects) {
          options.maxRedirects = config.maxRedirects;
        }
        transport = isHttpsProxy ? httpsFollow : httpFollow;
      }
      if (config.maxBodyLength > -1) {
        options.maxBodyLength = config.maxBodyLength;
      }
      if (config.insecureHTTPParser) {
        options.insecureHTTPParser = config.insecureHTTPParser;
      }
      var req = transport.request(options, function handleResponse(res) {
        if (req.aborted) return;
        var stream = res;
        var lastRequest = res.req || req;
        if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) {
          switch (res.headers['content-encoding']) {
            case 'gzip':
            case 'compress':
            case 'deflate':
              stream = stream.pipe(zlib.createUnzip());
              delete res.headers['content-encoding'];
              break;}

        }
        var response = {
          status: res.statusCode,
          statusText: res.statusMessage,
          headers: res.headers,
          config: config,
          request: lastRequest };

        if (config.responseType === 'stream') {
          response.data = stream;
          settle(resolve, reject, response);
        } else {
          var responseBuffer = [];
          var totalResponseBytes = 0;
          stream.on('data', function handleStreamData(chunk) {
            responseBuffer.push(chunk);
            totalResponseBytes += chunk.length;
            if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
              stream.destroy();
              reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded', config, null, lastRequest));
            }
          });
          stream.on('error', function handleStreamError(err) {
            if (req.aborted) return;
            reject(enhanceError(err, config, null, lastRequest));
          });
          stream.on('end', function handleStreamEnd() {
            var responseData = Buffer.concat(responseBuffer);
            if (config.responseType !== 'arraybuffer') {
              responseData = responseData.toString(config.responseEncoding);
              if (!config.responseEncoding || config.responseEncoding === 'utf8') {
                responseData = utils.stripBOM(responseData);
              }
            }
            response.data = responseData;
            settle(resolve, reject, response);
          });
        }
      });
      req.on('error', function handleRequestError(err) {
        if (req.aborted && err.code !== 'ERR_FR_TOO_MANY_REDIRECTS') return;
        reject(enhanceError(err, config, null, req));
      });
      if (config.timeout) {
        var timeout = parseInt(config.timeout, 10);
        if (isNaN(timeout)) {
          reject(createError('error trying to parse `config.timeout` to int', config, 'ERR_PARSE_TIMEOUT', req));
          return;
        }
        req.setTimeout(timeout, function handleRequestTimeout() {
          req.abort();
          var transitional = config.transitional || defaults.transitional;
          reject(createError('timeout of ' + timeout + 'ms exceeded', config, transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED', req));
        });
      }
      if (config.cancelToken || config.signal) {
        onCanceled = function onCanceled(cancel) {
          if (req.aborted) return;
          req.abort();
          reject(!cancel || cancel && cancel.type ? new Cancel('canceled') : cancel);
        };
        config.cancelToken && config.cancelToken.subscribe(onCanceled);
        if (config.signal) {
          config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
        }
      }
      if (utils.isStream(data)) {
        data.on('error', function handleStreamError(err) {
          reject(enhanceError(err, config, null, req));
        }).pipe(req);
      } else {
        req.end(data);
      }
    });
  };return module.exports;});